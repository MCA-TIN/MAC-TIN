

#面相面试的C++基础知识

### 多态的实现

##### 如何得到虚函数表的指针?
    虚函数表位于前4个字节（一个指针的大小）。


##### 析构函数为什么要声明为虚函数?
    当我们使用多态机制时，父类的指针指向派生类时，如果析构函数未定义为虚函数，则使用的析构函数仍为父类的析构函数，导致内存的泄漏。

##### 构造函数为什么不能声明为虚函数?
    虚函数表需要内存空间，而构造函数是用来开辟空间，互相矛盾。

##### C++实现多态有哪些方式?
    重载、重写、模版

### C++11新特性

##### shared_ptr的实现机制？
    是根据引用次数来决定是否析构，引用次数的更新是原子性的。对于托管的对象需要用户手动设置锁，保证对托管对象更新的原子性，保证多线程安全。

##### weak_ptr 存在的理由？
    shared_ptr 的析构机制是根据引用次数.
    当一个双向链表节点通过 shared_ptr 来托管指针且节点均通过 shared_ptr 保存时对于每一个节点对象，shared_ptr 的引用次数均为2，当我们想析构一个节点时，另外一个实例保管在他的前后节点中，导致引用次数仍不为0，shared_ptr 不会完成析构操作，导致节点的内存仍未释放。当使用 weak_ptr 来负责托管对象时，并不影响引用次数的大小，对于链表的节点引用次数始终为1。
    
    两个shared_ptr相互引用会造成死锁，而weak_ptr引用shared_ptr不会增加引用计数。

##### 智能指针的初始化
    提供一个托管的指针，以及对应的析构函数。
```cpp
shared_ptr<connection> p(&c, end_connection);
```
    




3.线程与进程的问题
3.1 进程是操作系统调度的基本单位，线程是CPU调度的最小单位。
3.2 进程拥有独立的内存空间，各个线程共享程序的内存空间。
3.3 什么是线程安全？线程安全的问题来自共享的内存空间，当多线程对同一个内存进行读写时，导致了内存数据可能被其余线程修改。如何保证线程安全，1.加锁，2.将所要操作的数据由子线程自己开辟操作，3.内存只读
3.4 进程的内存问题，由操作系统完成内存空间的分配，以及虚拟地址到物理地址的映射。按照粒度的大小，可以分为页式管理，段式管理。

4.c++11 的新特性（除智能指针外）
4.1 function 匿名函数，也叫Lambda函数，[传值]（参数列表）{函数实现}
4.2 初始化列表的必要性，1.对 const 类型的初始化，2.完成对当前类的类成员变量的初始化A(a)
！！！！4.3 迭代器的实现
！！！4.4 模版类 template<T> 的实现
4.3 mallco 和 new 的区别
4.4 const 和 define

N-1 基本问题
5.std 库的实现，红黑树，堆

6.c的内存分配管理，内存分为5个区，1.堆，用于程序的内存动态分配，空间比较大，用于malloc，new分配内存2.栈，栈内存有限，1/4/8mb 3.静态存储区，在程序的整个运行期间均存在，如全局变量，static变量。

7.虚拟内存的大小由操作系统的寻址空间决定，32位系统的寻址空间大小为4gb，64位系统的寻址空间为2^64,但实际还是需要看具体的操作系统，linux 的寻址空间为 2^48 大约为256TB的可用空间。由于物理内存总是有限，当不同的进程运行时，会将不在使用状态的物理内存与磁盘空间swap，让有需要的进程先使用物理内存。
N. 结构体的内存对齐问题


