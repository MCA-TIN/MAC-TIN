<div align="left">

## 面试的C++基础知识

### 多态的实现

##### 什么是虚函数？
    在类里将一个方法用 virtual 关键字声明该方法，完成虚函数的定义，虚函数的作用是为了允许基类的指针或引用调用子类的函数实现。完成动态联编。

##### 什么是纯虚函数？
    纯虚函数是在基类中声明的虚函数，在虚函数的方法原型后加"= 0"，完成纯虚函数的定义，如 virtual fun() = 0; 纯虚函数要求派生类必须定义自己的实现方法。

##### 如何得到虚函数表的指针?
    虚函数表位于前4个字节（一个指针的大小）。


##### 析构函数为什么要声明为虚函数?
    当我们使用多态机制时，父类的指针指向派生类时，如果析构函数未定义为虚函数，则使用的析构函数仍为父类的析构函数，导致内存的泄漏。

##### 构造函数为什么不能声明为虚函数?
    虚函数表需要内存空间，而构造函数是用来开辟空间，互相矛盾。

##### C++实现多态有哪些方式?
    重载、重写、模版

### C++11新特性

##### shared_ptr的实现机制？
    是根据引用次数来决定是否析构，引用次数的更新是原子性的。对于托管的对象需要用户手动设置锁，保证对托管对象更新的原子性，保证多线程安全。

##### weak_ptr 存在的理由？以及例子
    shared_ptr 的析构机制是根据引用次数.
    当一个双向链表节点通过 shared_ptr 来托管指针时，且节点均通过 shared_ptr 保存时，对于每一个节点对象，shared_ptr 的引用次数均为2，当我们想析构一个节点时，另外一个实例保管在他的前后节点中，导致引用次数仍不为0，shared_ptr 不会完成析构操作，导致节点的内存仍未释放。当使用 weak_ptr 来负责托管对象时，并不影响引用次数的大小，对于链表的节点引用次数始终为1。

##### 智能指针的初始化
    提供一个托管的指针，以及对应的析构函数。
    指针指针只能托管堆的数据，一般操作都是
    ```cpp
    auto ptr = std::shared_ptr<char[]> (new char[3]);
    shared_ptr<connection> p(&c, end_connection);
    ```
    

##### 模版
    模版参数实例化时，与一般函数一样，需要声明(.h)以及定义(.cpp)才能使用，但是模版在编译过程中，编译器只会检查模版声明的正确性，只有在调用模版的时候才会去查找对应的函数定义，根据函数定义去生成对应参数的实例化方法。所以当我们对模版只写了声明(.h)，而没有定义时(.cpp)，它能通过编译检查，但是当我们具体去调用该方法时，会报错（没有对应的实例化方法）。说明模版在调用时才会展开对应参数的实例化方法。

##### function函数
    function 匿名函数，也叫Lambda函数，[传值]（参数列表）{函数实现}



### 线程与进程的问题
    1 进程是操作系统调度的基本单位，线程是CPU调度的最小单位。
    2 进程拥有独立的内存空间，各个线程共享程序的内存空间。
    3 什么是线程安全？线程安全的问题来自共享的内存空间，当多线程对同一个内存进行读写时，导致了内存数据可能被其余线程修改。如何保证线程安全，1.加锁，2.将所要操作的数据由子线程自己开辟操作，3.内存只读
    
### 其他小知识(需要补充完善)

    1 初始化列表的必要性有如下几点，1.对 const 类型的初始化，2.完成对当前类的类成员变量的初始化A(a)
    2.mallco 和 new 的区别
    3.const 和 define 的区别
    4.程序进程运行申请的内存由操作系统进行分配，操作系统提供给进程的内存其实是虚拟内存，分配的内存通过操作系统完成映射。虚拟内存的大小由操作系统的寻址空间决定，32位系统的寻址空间大小为4gb，64位系统的寻址空间为2^64,但实际还是需要看具体的操作系统，linux 的寻址空间为 2^48 大约为256TB的可用空间。由于物理内存总是有限，当不同的进程运行时，会将不在使用状态的物理内存与磁盘空间swap，让有需要的进程先使用物理内存。


### 基本问题（需要补充完善）
    1.std 库的实现，红黑树，堆
    2.c的内存分配管理，内存分为3个区，1.堆，用于程序的内存动态分配，空间比较大，用于malloc，new分配内存2.栈，栈内存有限，1/4/8mb 3.静态存储区，在程序的整个运行期间均存在，如全局变量，static变量。
    3. 结构体的内存对齐问题


### 内存问题
    1. 当调用 free 函数的时候，操作系统如何知道要释放的内存大小
    2. delete 和 detele[] 的区别， 为什么必须有 delete[]
